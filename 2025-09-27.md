# QR-AgentDoc 技术实现流程

QR-AgentDoc 的运行流程遵循“规划–执行–反思”循环，由一个总控调度器（Orchestrator）协调四个核心智能体模块。整个流程以用户问题为输入，以最终答案及可审计执行报告为输出，具体步骤如下：

---

## 1. 输入接收与初步分析

- 系统接收用户原始问题 \( Q_{\text{orig}} \)。
- **Planner-Agent** 对问题进行语义解析，识别任务类型（如事实检索、数值比较、趋势总结等）和关键实体。

---

## 2. 生成结构化执行计划树

- Planner-Agent 生成一个结构化的 **执行计划树（Execution Plan Tree）**，以 JSON 格式表示，包含以下字段：
  - `goal`：整体任务目标；
  - `steps`：有序步骤列表，每个步骤包含：
    - `step_id`：唯一标识；
    - `description`：自然语言描述；
    - `tool_needed`：所需工具智能体名称；
    - `sub_queries` 或 `inputs`：输入参数（可引用前序步骤的输出）；
    - `dependencies`：依赖的前置步骤 ID 列表。

示例：
```json
{
  "goal": "比较Q4和Q3的净利润差异",
  "steps": [
    {
      "step_id": 1,
      "description": "定位并提取Q4和Q3的财务数据",
      "tool_needed": "retrieval_agent",
      "sub_queries": ["Q4 net profit value", "Q3 net profit value"],
      "dependencies": []
    },
    {
      "step_id": 2,
      "description": "计算两者差异",
      "tool_needed": "calculator_agent",
      "inputs": ["step_1_result.q4_profit", "step_1_result.q3_profit"],
      "dependencies": [1]
    },
    {
      "step_id": 3,
      "description": "生成最终的比较性陈述",
      "tool_needed": "generator_agent",
      "inputs": ["step_2_result.difference"],
      "dependencies": [2]
    }
  ]
}
```

---

## 3. 调度与多智能体执行

- **总控调度器**解析计划树，按依赖关系调度工具智能体：
  - 无依赖步骤可并行执行；
  - 有依赖步骤在前置步骤成功完成后触发。
- 各工具智能体独立运行，仅处理指定任务：
  - `Retrieval-Agent`：接收子查询，在文档库中检索相关片段，返回结果及置信度（0.0–1.0）；
  - `Calculator-Agent`：执行数值运算（如差值、百分比变化）；
  - `Table-Parser-Agent`：解析表格结构，支持行列查询与聚合；
  - `Generator-Agent`：基于结构化输入生成自然语言回答；
  - 其他领域专用智能体（如 `LegalClause-Agent`）可动态注册。

---

## 4. 在线试错与自适应重写

- 每个步骤分配一个 **试错预算 \( K \)**（默认 \( K=3 \)）。
- 若工具智能体返回低置信度（如 < 0.3）或空结果：
  - 调度器激活 **Rewriter-Agent**；
  - Rewriter-Agent 接收原始子查询、失败日志及上下文，生成语义等价但表述不同的新查询（如术语替换、句式重构）；
  - 使用新查询重新调用原工具智能体，消耗一次试错预算；
  - 重复直至成功或预算耗尽。
- 若后续步骤检测到逻辑矛盾（如数值不一致），触发回溯重试机制，重新执行相关前置步骤。

---

## 5. 全过程轨迹记录

- 调度器实时记录完整执行轨迹，包括：
  - 初始计划树；
  - 每次工具调用的输入、输出、置信度、时间戳；
  - 所有重写尝试与失败原因；
  - 步骤间的数据传递关系。

---

## 6. 过程评估与报告生成

- 任务完成后，**Auditor-Agent** 被调用，执行以下操作：
  1. **计算进度率（Process Rate）**：
     \[
     \text{Process Rate} = \frac{\text{成功执行的步骤数}}{\text{计划总步骤数}}
     \]
  2. **统计资源消耗**：总 Token 使用量、API 调用次数、端到端延迟；
  3. **生成可审计报告**，包含：
     - 初始计划；
     - 每一步执行日志（含重试记录）；
     - 最终答案；
     - 过程评估指标（进度率、置信度分布、资源开销）。

---

## 7. 输出

系统返回两项内容：
- **最终答案**：由 Generator-Agent 生成的自然语言响应；
- **执行报告**：结构化 JSON 或 Markdown 格式的可解释性文档，支持人工审核与系统调试。

---



## LexKeyPlan：前瞻性任务规划的基石

**主要贡献阶段**：步骤 2（生成结构化执行计划树）

LexKeyPlan 提出“前瞻性规划（Proactive Planning）”范式，强调在执行前生成明确的未来导向计划。QR-AgentDoc 借鉴其核心理念，将原始的“关键词规划”泛化为更通用、结构化的 **任务规划树（Task Plan Tree）**。

- 该规划树以 JSON 形式定义问题解决的宏观步骤；
- 每个叶子节点对应一个可执行的原子任务；
- 任务间通过依赖关系显式建模执行顺序。

此设计为整个推理流程提供了逻辑蓝图与可追踪的执行路径，实现了从“盲目执行”到“计划驱动”的范式升级。

---

## QueryAgent：动态试错与自适应重写的引擎

**主要贡献阶段**：步骤 4（在线试错与自适应重写）

QueryAgent 的核心创新在于将推理过程与可执行动作紧密耦合，并引入 **试错预算（Error Budget）** 与 **查询改写（Query Rewriting）** 机制。QR-AgentDoc 直接继承并扩展了这一思想：

- 为每个规划步骤分配最大重试次数 \( K \)；
- 工具智能体返回结果时附带置信度与日志；
- 当置信度不足或结果为空时，激活 **Rewriter-Agent**，基于上下文智能重构子查询（如术语替换、句式调整）；
- 支持因后续步骤发现逻辑矛盾而触发的回溯重试。

该机制实现了“写一步、跑一步、错就改”的动态交互模式，显著提升了系统在噪声或模糊查询下的鲁棒性。

---

## MAIN-RAG：智能体化执行与可解释轨迹

**主要贡献阶段**：步骤 3（调度与多智能体执行）与 步骤 5（全过程轨迹记录）

MAIN-RAG 首次系统性地将传统 RAG 流程“智能体化（Agentic）”，QR-AgentDoc 全面采纳并深化了这一架构思想：

- 将检索、计算、表格解析、文本生成等功能封装为 **独立、可插拔的工具智能体**（如 `Retrieval-Agent`、`Calculator-Agent` 等）；
- 总控调度器根据计划树动态调用相应智能体，支持并行与依赖调度；
- 每次调用均记录输入、输出、时间戳与状态，形成 **完整执行轨迹**；
- 引入 **一致性回环（Consistency Loop）** 机制，用于检测跨步骤逻辑冲突并触发重试。

该设计不仅提升了系统的模块化与领域适应性，也为过程审计提供了结构化数据基础。

---

## LegalAgentBench：过程导向的内建评估体系

**主要贡献阶段**：步骤 6（过程评估与报告生成）

LegalAgentBench 突破传统“仅评估最终答案”的局限，提出对推理过程进行细粒度评估。QR-AgentDoc 将其方法论转化为内建功能：

- 引入 **进度率（Process Rate）** 作为核心过程指标：
  \[
  \text{Process Rate} = \frac{\text{成功执行的步骤数}}{\text{计划总步骤数}}
  \]
- 设计 **Auditor-Agent**，在任务结束后自动分析执行轨迹；
- 输出包含资源消耗（Token 数、API 调用、延迟）、步骤成功率、重试分布等维度的 **可审计报告**。


---
标准流程

1. 加载文档并进行高层次切分
将一份庞大的文档加载进来，并切分成少量的大块内容。这样做相当于为智能体绘制一张地图，让它能够先看到整体结构。这避免了传统 RAG 中费时的预嵌入步骤。
2. Router Agent
引入一个基于小型、快速大模型的路由智能体。它的任务是快速浏览这些大块内容，并初步判断哪些部分可能最相关。负责把注意力引导到正确的区域。
3. 逐层缩放
系统会不断对选中的内容进行更细致的切分：先把相关的大块分成更小的子块，再次路由。通过这种逐层放大的方式，智能体能够逐渐聚焦到真正关键的信息。类似人类读书时，先翻目录 → 找到章节 → 再聚焦到某一页的重点段落。
4. Synthesizer Agent
当最相关的段落被提炼出来后，系统会启用一个更强大的综合智能体。它负责把这些关键信息整合成一份完整的答案。每个论述都带有精确的引用，确保回答不仅有逻辑，还能追溯到具体出处。
5. Evaluation Agent
最后，系统会启用一个评价智能体，充当公正的审查员。它会对最终答案进行打分，评估回答是否忠实于原文、是否切题。这种评分能提供定量的置信度指标，帮助用户判断答案的可靠性。
智能体 RAG 的关键在于：把不同的任务交给最合适的模型来完成，从而在性能与成本之间取得平衡。
一般来说，一个典型的 Agentic RAG 系统至少包含三类 AI 组件：
Routing
任务：快速筛选大段文本，找到潜在相关部分。
模型选择：轻量级、速度快的小模型（例如 8B 规模的模型）。
优势：运行成本低，效率高。
Synthesis
任务：深度理解内容，并把来自不同段落的信息组合成连贯的答案。
模型选择：更强大的大模型（如 70B 规模）。
优势：具备强推理能力，能保证输出的准确性和完整性。
Evaluation
任务：作为裁判，判断其他模型生成的内容是否可靠、是否切题。
模型选择：顶级大模型，用于确保评价结果的权威性和可信度。

